import pandas as pd
import duckdb
import os
import re
import json
from rapidfuzz import process, fuzz
from collections import Counter

# --- Configuration ---
RAW_FILE = "data/manual_scrapes/2015/ncaa_pbp_2015-11-13.csv"
DB_PATH = "data/warehouse.duckdb"
OUTPUT_FILE = "data/fact_play_historical_2015_clean.csv"

def normalize_name(n):
    # Remove leading #XX, remove spaces, uppercase
    n = re.sub(r'^\d+\s+', '', n)
    return n.upper().replace(" ", "")

def parse_header_teams(game_df):
    for text in game_df['raw_text']:
        if "| Score |" in text:
            parts = [p.strip() for p in text.split("|")]
            if len(parts) >= 4:
                return parts[1], parts[3]
    return None, None

def main():
    con = duckdb.connect(DB_PATH)
    team_df = con.execute("SELECT id, school, displayName FROM dim_teams").fetchdf()
    df = pd.read_csv(RAW_FILE)
    
    # Pick a single game for the "Try it out" task: San Fran St vs St Mary's
    contest_id = 239560
    game_df = df[df['contest_id'] == contest_id].sort_index()
    
    print(f"--- Cleaning Game {contest_id} ---")
    
    # Pass 1: Global Sweep (The Roster)
    stats_seen = Counter()
    all_mentioned = set()
    
    for row in game_df['raw_text']:
        # Extract names from raw events
        # Logic: If it's not a sub/timeout, the first part is usually the name
        parts = [p.strip() for p in row.split("|")]
        if len(parts) < 4: continue
        
        for evt in [parts[1], parts[3]]:
            if not evt: continue
            if "Enters" in evt or "Leaves" in evt or "Timeout" in evt:
                name = evt.split("Enters")[0].split("Leaves")[0].strip()
                all_mentioned.add(normalize_name(name))
                continue
            
            # Stat event: "JACKSON,WARREN made Layup"
            first_bit = evt.split(" ")[0]
            if "," in first_bit:
                name = normalize_name(first_bit)
                stats_seen[name] += 1
                all_mentioned.add(name)

    print(f"Roster size discovered: {len(all_mentioned)}")
    # Most active players (likely the starters/rotation)
    most_active = [p for p, c in stats_seen.most_common(15)]

    # Pass 2 & 3: Lineup Prop (Modified from prototype)
    # [Simplified for demo: just showing the 'Ghost Fill' logic]
    # In a full run, we'd use the V3 solver here.
    
    # Let's mock a "Collapsed Lineup" at the start of the game
    # (Normally generated by backprop)
    mock_lineup = {'JACKSON,WARREN', 'JONES,ANDRE', 'WORMLEY,FLOYD'} # Only 3 found
    
    print(f"\nBefore Ghost Fill: {mock_lineup} (Size: {len(mock_lineup)})")
    
    # Pass 4: The Holistic Fill
    if len(mock_lineup) < 5:
        # Who is active but not in the lineup and not known on the bench?
        candidates = [p for p in most_active if p not in mock_lineup]
        for ghost in candidates:
            mock_lineup.add(ghost)
            if len(mock_lineup) == 5: break
            
    print(f"After Ghost Fill: {mock_lineup} (Size: {len(mock_lineup)})")

    # Pass 5: Final Schema Alignment (Matching 2025)
    clean_rows = []
    
    # Match Teams for IDs
    h_raw, a_raw = parse_header_teams(game_df)
    # [Fuzzy match logic skipped for brevity here, assume IDs]
    h_id, a_id = 571, 253 

    for i, raw_row in game_df.iterrows():
        parts = [p.strip() for p in raw_row['raw_text'].split("|")]
        if len(parts) < 4: continue
        
        # Structure the 'onFloor' as a JSON-like list of dicts to match 2025 dictionary
        # 2025 Format: [{'id': 605, 'name': 'Gavin Dowling', 'team': 'IU Columbus'}, ...]
        on_floor_struct = []
        for p in mock_lineup: # Simplifying: using the fixed mock to show format
             on_floor_struct.append({"id": None, "name": p, "team": "HOME"})
        
        clean_rows.append({
            "gameSourceId": str(contest_id),
            "season": 2015,
            "clock": parts[0],
            "playText": raw_row['raw_text'],
            "homeScore": parts[2].split("-")[0].strip() if "-" in parts[2] else 0,
            "awayScore": parts[2].split("-")[1].strip() if "-" in parts[2] else 0,
            "onFloor": json.dumps(on_floor_struct) # The 2025-compatible column
        })

    clean_df = pd.DataFrame(clean_rows)
    clean_df.to_csv(OUTPUT_FILE, index=False)
    print(f"\nFinal cleaned sample saved to {OUTPUT_FILE}")
    print("Schema alignment: 'onFloor' now contains structured JSON identical to 'fact_play_raw'!")

if __name__ == "__main__":
    main()
